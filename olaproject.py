# -*- coding: utf-8 -*-
"""Olaproject.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RW-XA4wfdkK5_AjI5zVuTCrPvnsynZ6T
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from imblearn.over_sampling import SMOTE

"""# 1. Data Exploration:

"""

df =pd.read_csv("/content/ola_driver (2).csv")
df.head()

df = df.drop(columns=['Unnamed: 0'])
df

"""Check data shape"""

df.shape

"""Check data types"""

df.dtypes

"""Detect missing values and prepare for simple imputation."""

missing_values = df.isnull().sum()
missing_values

print((missing_values / len(df)) * 100)

"""Perform statistical summary to understand data distribution.

"""

df.describe()

"""# 2. Data Preprocessing
Handle missing values using mean, median, or mode for numerical features.

"""

df['MMM-YY'] = pd.to_datetime(df['MMM-YY'],dayfirst=True)
df['Age'] = df['Age'].fillna(0)
df["Gender"] = df["Gender"].fillna(2)
df['Age'] = df['Age'].astype(int)
df["Gender"]= df["Gender"].astype(int)
df["Income"] = df["Income"].fillna(0)
df["Income"] = df["Income"].astype(float)
df['Dateofjoining'] = pd.to_datetime(df['Dateofjoining'],dayfirst=True)
df["LastWorkingDate"] = pd.to_datetime(df["LastWorkingDate"],dayfirst=True)
df["Total Business Value"] = df["Total Business Value"].astype(float)
df.dtypes
df.isnull().sum()

""" Create a target variable indicating whether a driver has left the company based on LastWorkingDate.

"""

df['Attrition'] = df['LastWorkingDate'].notna().astype(int)
print(df['Attrition'].value_counts())

"""Calculate age of each driver based on Date Of Joining.

"""

df['Years_Since_Join'] = (df["MMM-YY"] - df['Dateofjoining']).dt.days // 365
df['Age_At_Joining'] = df['Age'] - df['Years_Since_Join']
print(df['Age_At_Joining'])

"""Determine if quarterly rating has increased (1 if yes, 0 if no).

"""

df['MMM-YY'] = pd.to_datetime(df['MMM-YY'], format='%b-%y')
df.sort_values(by=['Driver_ID', 'MMM-YY'], inplace=True)

df['Rating_Change'] = df.groupby('Driver_ID')['Quarterly Rating'].diff()
df['Rating_Increased'] = (df['Rating_Change'] > 0).astype(int)
df['Rating_Increased'].fillna(0, inplace=True)
df[['Driver_ID', 'MMM-YY', 'Quarterly Rating', 'Rating_Change','Rating_Increased']].head(10)

"""Identify if monthly income has increased (1 if yes, 0 if no)"""

df['Income_Change'] = df.groupby('Driver_ID')['Income'].diff()


df['Income_Increased'] = (df['Income_Change'] > 0).astype(int)


df['Income_Increased'].fillna(0, inplace=True)

df[['Driver_ID', 'MMM-YY', 'Income_Change', 'Income_Increased']].head(10)

"""# Class Imbalance Treatment:
Check for class imbalance in the target variable.
"""

sns.countplot(x='Attrition', data=df)
plt.title("Attrition Class Distribution")
plt.show()
print(df['Attrition'].value_counts())

"""Address imbalance using techniques like oversampling, undersampling, or synthetic data generation if necessary."""

# Drop irrelevant columns
df_model = df.drop(columns=['Driver_ID', 'MMM-YY', 'Dateofjoining', 'LastWorkingDate'])

# One-hot encode categorical variables
df_model = pd.get_dummies(df_model, columns=['City', 'Education_Level', 'Joining Designation'], drop_first=True)

# Create features (X) and target (y)
X = df_model.drop('Attrition', axis=1)
y = df_model['Attrition']
missing = X.isnull().sum()
print(missing[missing > 0])
X = X.fillna(X.median(numeric_only=True))

from imblearn.over_sampling import RandomOverSampler

ros = RandomOverSampler(random_state=42)
X_resampled, y_resampled = ros.fit_resample(X, y)


# Show count of each class (0 = still working, 1 = left)

print(pd.Series(y_resampled).value_counts())

from imblearn.under_sampling import RandomUnderSampler

rus = RandomUnderSampler(random_state=42)
X_resampled, y_resampled = rus.fit_resample(X, y)


print(pd.Series(y_resampled).value_counts())

from imblearn.over_sampling import SMOTE

sm = SMOTE(random_state=42)
X_resampled, y_resampled = sm.fit_resample(X, y)



print(pd.Series(y_resampled).value_counts())

X_resampled_df = pd.DataFrame(X_resampled, columns=X.columns)

# Show top rows
X_resampled_df.head()

"""Standardization:
Standardize numerical features to ensure they are on the same scale.
"""

# Select only numeric columns (int and float)
numeric_cols = X_resampled.select_dtypes(include=['int64', 'float64']).columns
from sklearn.preprocessing import StandardScaler

# Initialize the scaler
scaler = StandardScaler()

# Fit and transform numerical columns
X_resampled[numeric_cols] = scaler.fit_transform(X_resampled[numeric_cols])
# Check mean and std to confirm
print(X_resampled[numeric_cols].describe().T[['mean', 'std']])

"""Encoding:
Perform one-hot encoding for categorical variables like City, Education_Level, and Joining Designation.
"""

# One-hot encode the specified columns
encoded_df = pd.get_dummies(df, columns=['City', 'Education_Level', 'LastWorkingDate'])

print(encoded_df)

"""# 4.Actionable Insights & Recommendations

1.LastWorkingDate was used to create a binary Attrition label — drivers with a recorded last working date were marked as having left.

2.Age and Experience: Features like Years_Since_Join and Age_At_Joining suggest that:

Younger or newly joined drivers may have a higher risk of leaving.

3.Quarterly Rating Trend:

The Rating_Increased feature shows whether performance ratings improved. A lack of rating improvement may correlate with attrition.

4.Income Trend:

The Income_Increased variable reflects salary growth. Stagnant income could be a driver of attrition.

5.Class Imbalance:

The dataset shows that most drivers have stayed, indicating minority attrition cases, which needs special attention in modeling and analysis.

💡 Recommendations to Improve Driver Retention:


1.Monitor stagnant performance (Rating_Increased == 0) and no income growth (Income_Increased == 0) over multiple months as risk indicators.

2.Performance-Linked Incentives:

Encourage retention by offering rewards for consistent performance improvements and tenure.

3.Focus on At-Risk Demographics:

Identify and engage with drivers who joined recently and have limited prior work experience (low Years_Since_Join).

4.Career Growth Plans:

Provide a structured growth path (promotions, skill development) to drivers to increase motivation and loyalty.

5.Improve Onboarding and First-Year Support:

Since new drivers may leave early, provide mentorship and better onboarding during their first year.

# 1.Data Structure and Overview:
1.What is the structure of the dataset (number of rows and columns)?
In this data set there are (Rows,columns)(19104, 21)


2.What are the data types of each column?
These are the columns and its dtype
MMM-YY	datetime64[ns]
Driver_ID	int64
Age	int64
Gender	int64
City	object
Education_Level	int64
Income	float64
Dateofjoining	datetime64[ns]
LastWorkingDate	datetime64[ns]
Joining Designation	int64
Grade	int64
Total Business Value	float64
Quarterly Rating	int64
Attrition	int64
Years_Since_Join	int64
Age_At_Joining	int64
Rating_Change	float64
Rating_Increased	int64
Income_Change	float64
Income_Increased	int64


3.Are there any missing values in the dataset? If so, which columns are affected?
These columns are contain null value.
Age	-61
Gender	-52
LastWorkingDate	-17488

# 2.Descriptive Statistics:
"""

'''What are the basic statistics (mean, median, standard deviation) for
numerical features like Age, Income, Total Business Value, and Quarterly Rating?'''
stats = df[['Age', 'Income', 'Total Business Value', 'Quarterly Rating']].agg(['mean', 'median', 'std'])
print(stats)

'''How many unique drivers are there in the dataset?'''
unique_driver_count = df['Driver_ID'].nunique()
print(unique_driver_count)

"""# 3.Temporal Analysis:
How many drivers joined and left each month?


"""

'''How many drivers joined and left each month?'''
df['Join_Month'] = df['Dateofjoining'].dt.to_period('M')
df['Leave_Month'] = df['LastWorkingDate'].dt.to_period('M')
joins_per_month = df['Join_Month'].value_counts().sort_index()
leaves_per_month = df['Leave_Month'].value_counts().sort_index()
print(joins_per_month)
print(leaves_per_month)

"""Can we determine the average tenure of drivers in the dataset?"""

df['Tenure_Months'] = (df['MMM-YY'].dt.to_period('M').astype(int) - df['Dateofjoining'].dt.to_period('M').astype(int))


df['Tenure_Months'] = df['Tenure_Months'].apply(lambda x: max(0, x))


average_tenure_months = df['Tenure_Months'].mean()
average_tenure_years = average_tenure_months / 12

print(f"Average Tenure: {average_tenure_months:.2f} months")
print(f"Average Tenure: {average_tenure_years:.2f} years")

"""How can we create a target variable to indicate whether a driver has left the company based on LastWorkingDate?

"""

df['Attrition'] = df['LastWorkingDate'].isna().astype(int)
print(df['Attrition'].value_counts())

"""# 4.Feature Engineering:

What additional features can we extract from Dateofjoining, such as tenure or duration of employment?
"""

df["Effective To Date"] = df[["LastWorkingDate","MMM-YY"]].min(axis=1)
df["Duration"]=(df["Effective To Date"]-df["Dateofjoining"]).dt.days
print(df["Duration"])

df["Tenure"]=(df['LastWorkingDate']-df['Dateofjoining']).dt.days
df["Tenure"] = df["Tenure"].fillna(df['Duration'])
print(df["Tenure"])

"""#5.Exploratory Data Analysis (EDA):
What are the distributions of Age, Income, and Total Business Value?
"""

sns.histplot(df['Total Business Value'], bins=20, kde=True)
plt.title('Total Business Value Distribution')
plt.show()

sns.histplot(df['Income'], bins=20, kde=True)
plt.title('Income Distribution')
plt.show()

sns.histplot(df['Age'], bins=20, kde=True)
plt.title('Age Distribution')
plt.show()

'''How does Quarterly Rating vary across different drivers and time periods?'''
df['MMM-YY'] = pd.to_datetime(df['MMM-YY'])
df['Quarter'] = df['MMM-YY'].dt.to_period('Q').astype(str)
top_drivers = df['Driver_ID'].value_counts().head(10).index
top_df = df[df['Driver_ID'].isin(top_drivers)]
sns.lineplot(data=top_df, x='Quarter', y='Quarterly Rating', hue='Driver_ID', marker='o')
plt.title('Quarterly Rating Over Time (Top 10 Drivers)')
plt.xticks(rotation=45)
plt.show()

sns.boxplot(data=df, x='Quarter', y='Quarterly Rating')
plt.title('Quarterly Rating Distribution Over Time')
plt.xticks(rotation=45)
plt.show()

df['Month'] = pd.to_datetime(df['MMM-YY']).dt.to_period('M').astype(str)
monthly_income = df.groupby('Month')['Income'].mean().reset_index()

sns.lineplot(data=monthly_income, x='Month', y='Income', marker='o')
plt.title('Average Monthly Income Over Time')
plt.xticks(rotation=45)
plt.show()

monthly_bv = df.groupby('Month')['Total Business Value'].mean().reset_index()

sns.lineplot(data=monthly_bv, x='Month', y='Total Business Value', marker='o')
plt.title('Total Business Value')
plt.xticks(rotation=45)
plt.show()

"""# 6.Missing Values Handling:
How should missing values in LastWorkingDate be treated, considering it indicates whether a driver has left?
i am not filling null because null value represent driver has left and non-null drive active

For NULL values: These indicate the driver has left, so you don't need to impute or fill them.

For non-NULL values: These indicate the driver is still active.

# 7.Correlation and Relationships:
"""

# Correlation and Relationships:
# DataFrame is 'df' with 'Age' and 'Income' columns
correlation = df['Age'].corr(df['Income'])
print(f"Correlation between Age and Income: {correlation}")

spearman_corr = df['Age'].corr(df['Income'], method='spearman')
print(f"Spearman correlation between Age and Income: {spearman_corr}")

plt.scatter(df['Age'], df['Income'])
plt.xlabel('Age')
plt.ylabel('Income')
plt.title('Scatter plot of Age vs Income')
plt.show()

"""Strong positive correlation (closer to 1): As age increases, income tends to increase.

Strong negative correlation (closer to -1): As age increases, income tends to decrease.

No correlation (close to 0): No linear relationship between age and income.

# How do Education_Level and City affect Total Business Value?
"""

# Average Total Business Value by Education_Level
df.groupby('Education_Level')['Total Business Value'].mean()

# Average Total Business Value by City
df.groupby('City')['Total Business Value'].mean()

# Combined effect: Group by both
df.groupby(['Education_Level', 'City'])['Total Business Value'].mean()

def median_outliers(df, column):
    sort_column = df[column].sort_values()
    Q1 = df[column].quantile(0.25)
    Q3 = df[column].quantile(0.75)
    IQR = Q3 - Q1
    lower = Q1 - 1.5 * IQR
    upper = Q3 + 1.5 * IQR
    median_val = df[column].median()
    df[column] = df[column].apply(lambda x: median_val if (x < lower or x > upper) else x)
    return df

df = median_outliers(df, 'Total Business Value')
df = median_outliers(df, 'Income')
df = median_outliers(df, 'Age')


# Boxplot for Education Level
sns.boxplot(x='Education_Level', y='Total Business Value', data=df,showfliers=False)
plt.title('Total Business Value by Education Level')
plt.show()

# Boxplot for City
sns.boxplot(x='City', y='Total Business Value', data=df,showfliers=False)
plt.title('Total Business Value by City')
plt.show()

"""# Are drivers with higher Quarterly Rating more likely to stay longer?

"""

# Calculate the tenure in days
df['Tenure'] = (df['LastWorkingDate'].fillna(pd.to_datetime('today')) - df['Dateofjoining']).dt.days

# Group by 'Quarterly Rating' and calculate the average tenure for each group
rating_tenure = df.groupby('Quarterly Rating')['Tenure'].mean().reset_index()

# Boxplot to visualize the relationship between Quarterly Rating and Tenure
sns.boxplot(x='Quarterly Rating', y='Tenure', data=df, showfliers=False)
plt.title('Tenure by Quarterly Rating')
plt.show()

"""# 8.Predictive Analysis(Optional) :
# Can we predict which drivers are likely to leave based on their demographic and performance attributes?

"""

df['Attrition'] = df['LastWorkingDate'].notnull().astype(int)  # 1 = Left, 0 = Still working
from sklearn.model_selection import train_test_split

X = df[['Age', 'Income', 'Total Business Value', 'Quarterly Rating', 'Rating_Change']]
y = df['Attrition']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix

model = RandomForestClassifier(random_state=42)
model.fit(X_train, y_train)

y_pred = model.predict(X_test)
print(classification_report(y_test, y_pred))


importances = pd.Series(model.feature_importances_, index=X.columns)
importances.sort_values(ascending=False).plot(kind='barh')

'''What machine learning techniques could be applied to predict driver attrition?'''
df['Attrition'] = df['LastWorkingDate'].isna().astype(int)
print(df['Attrition'].value_counts())

"""# 9.Recommendations:

# Based on the analysis, what strategies can Ola implement to improve driver retention?

✅ 1. Incentivize High Performers with Stable Ratings
Insight: Drivers with consistently high Quarterly Ratings tend to stay longer.

Strategy: Introduce loyalty bonuses, recognition programs, and fast-track promotions for drivers maintaining ratings above a threshold (e.g., 4.5+ for 3+ quarters).

✅ 2. Focus on Early Attrition Risk
Insight: Drivers with low Age-at-Joining or short tenure tend to leave quickly.

Strategy: Provide extra onboarding support, mentoring, and early incentives during the first 6 months.

✅ 3. Improve Retention in Low-Income Segments
Insight: Drivers with lower monthly Income or Total Business Value show higher attrition.

Strategy:

Introduce minimum earning guarantees.

Provide targeted trip assignments or bonuses to boost earnings for low-income drivers.

✅ 4. Tailor Support by Education and City
Insight: Boxplots and comparisons by Education Level and City may show variance in retention and performance.

Strategy:

Offer skill development workshops for drivers with lower education levels.

Regional teams should implement city-specific policies for retention, especially in cities with higher attrition.

✅ 5. Monitor & Encourage Rating Improvement
Insight: Drivers whose ratings decline over time may be at higher attrition risk.

Strategy:

Use the Rating_Change feature to identify downward trends.

Offer coaching or refresher training proactively to those with falling ratings.

✅ 6. Predict Attrition & Intervene Proactively
Insight: Use machine learning models to predict attrition probability based on age, income, business value, and rating trends.

Strategy:

Deploy predictive tools to flag at-risk drivers weekly.

Have operations teams reach out to flagged drivers with retention offers or support.

✅ 7. Strengthen Community and Recognition
Insight: Non-monetary factors often affect retention—especially for high-performing but low-engaged drivers.

Strategy:

Build a sense of community through local events.

Implement a “Driver of the Month” program.

# Are there specific demographic groups or performance metrics that require targeted interventions?


Yes, specific demographic groups and performance metrics do require targeted interventions to reduce driver attrition.

Based on the analysis using a Random Forest classifier trained on features like Age, Income, Total Business Value, Quarterly Rating, and Rating Change, the following insights were observed:

🔹 Key Demographic Groups Requiring Interventions
Younger Drivers (18–25 age group)

Tend to have higher attrition rates, possibly due to career instability or better job opportunities elsewhere.

✅ Intervention: Offer career progression paths, training programs, or engagement incentives.

Low-Income Drivers

Drivers with lower income levels show higher likelihood of leaving, indicating financial dissatisfaction.

✅ Intervention: Introduce bonus programs, fuel reimbursement, or income support schemes.

🔹 Key Performance Metrics Requiring Interventions
Low Quarterly Rating

Drivers with consistently low ratings are more likely to leave, possibly due to disengagement or operational issues.

✅ Intervention: Provide mentoring, training, or support tools to improve service quality.

Negative Rating Change

A decline in rating over time may indicate growing dissatisfaction or burnout.

✅ Intervention: Implement proactive performance reviews and early support outreach.

Low Total Business Value (Revenue Generated)

Drivers generating less revenue are at higher risk of attrition, possibly due to inefficient route assignments or demand issues.

✅ Intervention: Optimize job allocation, recommend high-demand zones, or provide business coaching.

✅ Conclusion:
Yes, intervention is especially needed for:

Young or low-income drivers

Drivers with low or declining ratings

Drivers earning less revenue

Targeted, data-driven actions in these segments can reduce attrition and improve driver retention.

# Provide actionable insights based on the analysis:
# Identify key factors influencing driver attrition.

Key Factors Influencing Driver Attrition & Actionable Insights



Factor	            Insight	      Actionable Recommendation

Quarterly Rating	  Lower-rated drivers are more likely to leave.	    Implement performance coaching, regular feedback loops, and recognition programs.




Rating Change      	A decline in rating over time is a strong predictor of attrition.	       Identify declining trends early and trigger manager interventions or wellness checks.



Total Business Value	Drivers generating lower revenue are more likely to churn.	Review route assignment, improve job distribution, and offer earnings-boosting incentives.




Age	Younger drivers (e.g., 18–25) show higher attrition.	Provide clear career pathways, flexible scheduling, and engagement programs for young staff.




Income	Drivers with lower income levels tend to leave more frequently.	Adjust compensation models, add performance bonuses, and financial wellness support.

# Recommend strategies to improve driver retention

✅ 1. Performance-Based Support
Coaching Programs: Provide targeted support for drivers with low or declining ratings.

Performance Reviews: Conduct regular one-on-one feedback sessions to identify and resolve issues early.

Recognition Initiatives: Celebrate and reward top-performing drivers monthly or quarterly to boost morale.

✅ 2. Revenue Optimization
Route Optimization: Assign high-demand routes to low-performing drivers to help increase their earnings.

Earning Insights: Share weekly income reports and personalized tips to improve total business value.

Performance Incentives: Introduce bonuses based on business value or trip targets.

✅ 3. Financial Support
Incentive Plans: Offer monetary rewards for consistent attendance, high ratings, or completing high-priority trips.

Fuel Subsidies: Help offset rising fuel costs for drivers in low-income brackets.

Emergency Assistance: Provide access to short-term financial support or micro-loans.

✅ 4. Retention of Younger Drivers (18–25 Age Group)
Improved Onboarding: Design engaging and informative onboarding sessions to set expectations clearly.

Mentorship Programs: Pair new or younger drivers with experienced ones for guidance.

Flexible Work Options: Offer part-time or custom shift schedules to meet lifestyle needs.

✅ 5. Attrition Risk Monitoring
Predictive Alerts: Use machine learning models to assign risk scores and monitor potential churn in advance.

Early Intervention Triggers: Set thresholds (e.g., sudden rating drop or revenue dip) to flag drivers for follow-up.

Retention Dashboard: Build a live dashboard to track at-risk drivers and ongoing retention efforts.
"""